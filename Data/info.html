<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
	<head>
		<meta name="qrichtext" content="1" />
			<style type="text/css">
				li { white-space: pre-wrap; }
				* { font-family: Verdana, sans-sarif; color: #333}
				h1 { margin-top: 0px; }
				p { font-size: 13px; }
				.sigma { display:flex;     font-size: 1.5em; padding: 0px; }
				.sigma * { margin: 0px; padding: 0px;}
				.sigma .sig {}
				.sigma .sig_low {     margin-top: 20px; font-size: 0.7em; margin-left: -17px; float: left; }
				.sigma .sig_end { font-size: 0.7em; margin-left: 0px; margin-top: 4px; }
			</style>
	</head>
	<body style="font-size:10pt; font-style:normal;">
		<h1>Das Partitionsproblem</h1>
		<h2>Definition</h2>
		<p>gegeben: Eine abzählbare Menge mit Elementen aus dem Bereich der natürlichen Zahlen, z.B.: a<sub>1</sub>, a<sub>2</sub>... a<sub>n</sub></p>
		<p>gesucht: Eine Teilmenge deren Elemente die exakt gleiche Summe haben wie die übrigen restlichen Elemente der ursprünglichen Menge</p>
		<h3>Mögliches Problem</h3>
		<p>Es kann vorkommen, dass die Menge nicht glatt durch 2 Teilbar ist und damit können nicht zwei gleichwertige Teilmengen gebildet werden, gesucht in diesem Fall ist eine Teilmenge die eine Differenz von +/- 1 zur anderen Teilmenge als Summe hat.</p>		
		<p>Dieses Problem wird von dem Programm hier gelöst, indem es auf diesen Fall überprüft und gegebenenfalls ein weiteres Element hinzufügt mit dem Wert von 1, die Menge wird hiermit glatt teilbar. Nach der Berechnung wird dieses eine Element wieder entfernt.</p>
		<h2>Herangehensweise und Schwierigkeiten</h2>
		<p>Im Fachjargon existieren zwei Phasen, in der einen sind relativ wenige Elemente mit hohen Werten die oftmals nicht entscheidbar sind, in der anderen sind viele Elemente mit niedrigen Werten bei denen es viele perfekte Lösungen gibt.
		<br />Die Schwierigkeit liegt hier, dass gegebenenfalls alle Möglichkeiten durchprobiert werden müssen, der Rechenaufwand steigt exponentiell mit der Anzahl von Elementen, weiter unten eine Tabelle der Rechenzeit mit verschiedener Anzahl von Elementen.</p>
		<p>Dieses Programm stützt sich auf die Wahrscheinlichkeit, dass es in der einfachen Phasen viele Möglichkeiten einer perfekten Lösung gibt und versucht diese Mithilfe verschiedener Algorithmen, die parallel via Multithreading ausgeführt werden, das Problem zu lösen.</p>
		<h2>"Worst-Case" Tabelle der Rechenzeit für alle Kombinationen:</h2>
		<p>Prozessor: Intel i7-3720QM <br/>Rechendauer:</p>
		<ul>
		<li><b>Anzahl Elemente - Rechenzeit</b></li>
		<li>03: 0.001001 Sec</li>
		<li>05: 0.001001 Sec </li>
		<li>07: 0.001001 Sec </li>
		<li>09: 0.012012 Sec </li>
		<li>11: 0.167167 Sec </li>
		<li>13: 3.08608  Sec </li>
		<li>15: 65.9339  Sec </li>
		<li>17: 2055.71 == 34,25 Minuten </li>
		</ul>
		<h2>Weiterführende Quellen zu dem Partitionsproblem</h2>
		<p><a href="https://de.wikipedia.org/wiki/Partitionsproblem">Wikipedia: https://de.wikipedia.org/wiki/Partitionsproblem</a></p>
		<p><a href="https://arxiv.org/abs/cs/9903011v1">Stephan Mertens - A complete anytime algorithm for balanced number partitioning https://arxiv.org/abs/cs/9903011v1</a></p>
		<hr>
		<h2>Hier ist nurnoch kram der gelöscht werden kann bevor das Projekt abgegeben wird</h2>
		<p>I 	&sub; { 1, 2, ..., n} mit <span class="sigma"><span class="sig">&sum;</span><span class="sig_low"><sub>i &isin; I</sub></span><span class="sig_end">a<sub>i</sub></span></span> = <span class="sigma"><span class="sig">&sum;</span><span class="sig_low"><sub>i &isin; I</sub></span><span class="sig_end">a<sub>i</sub></span></span></p>
		<h2><i>Vorgeschichte</i></h2>
		<p>Wir möchten darauf hinweisen, dass wir euch nur die 
		</p>
	</body>
</html>